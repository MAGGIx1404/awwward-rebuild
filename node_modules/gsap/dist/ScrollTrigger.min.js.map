{"version":3,"file":"ScrollTrigger.min.js","sources":["../src/ScrollTrigger.js"],"sourcesContent":["/*!\n * ScrollTrigger 3.8.0\n * https://greensock.com\n *\n * @license Copyright 2008-2021, GreenSock. All rights reserved.\n * Subject to the terms at https://greensock.com/standard-license or for\n * Club GreenSock members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/\n/* eslint-disable */\n\nlet gsap, _coreInitted, _win, _doc, _docEl, _body, _root, _resizeDelay, _raf, _request, _toArray, _clamp, _time2, _syncInterval, _refreshing, _pointerIsDown, _transformProp, _i, _prevWidth, _prevHeight, _autoRefresh, _sort, _suppressOverwrites, _ignoreResize,\n\t_limitCallbacks, // if true, we'll only trigger callbacks if the active state toggles, so if you scroll immediately past both the start and end positions of a ScrollTrigger (thus inactive to inactive), neither its onEnter nor onLeave will be called. This is useful during startup.\n\t_startup = 1,\n\t_proxies = [],\n\t_scrollers = [],\n\t_getTime = Date.now,\n\t_time1 = _getTime(),\n\t_lastScrollTime = 0,\n\t_enabled = 1,\n\t_passThrough = v => v,\n\t_getTarget = t => _toArray(t)[0] || (_isString(t) ? console.warn(\"Element not found:\", t) : null),\n\t_round = value => Math.round(value * 100000) / 100000 || 0,\n\t_windowExists = () => typeof(window) !== \"undefined\",\n\t_getGSAP = () => gsap || (_windowExists() && (gsap = window.gsap) && gsap.registerPlugin && gsap),\n\t_isViewport = e => !!~_root.indexOf(e),\n\t_getProxyProp = (element, property) => ~_proxies.indexOf(element) && _proxies[_proxies.indexOf(element) + 1][property],\n\t_getScrollFunc = (element, {s, sc}) => { // we store the scroller functions in a alternating sequenced Array like [element, verticalScrollFunc, horizontalScrollFunc, ...] so that we can minimize memory, maximize performance, and we also record the last position as a \".rec\" property in order to revert to that after refreshing to ensure things don't shift around.\n\t\tlet i = _scrollers.indexOf(element),\n\t\t\toffset = sc === _vertical.sc ? 1 : 2;\n\t\t!~i && (i = _scrollers.push(element) - 1);\n\t\treturn _scrollers[i + offset] || (_scrollers[i + offset] = _getProxyProp(element, s) || (_isViewport(element) ? sc : function(value) { return arguments.length ? (element[s] = value) : element[s]; }));\n\t},\n\t_getBoundsFunc = element => _getProxyProp(element, \"getBoundingClientRect\") || (_isViewport(element) ? () => {_winOffsets.width = _win.innerWidth; _winOffsets.height = _win.innerHeight; return _winOffsets;} : () => _getBounds(element)),\n\t_getSizeFunc = (scroller, isViewport, {d, d2, a}) => (a = _getProxyProp(scroller, \"getBoundingClientRect\")) ? () => a()[d] : () => (isViewport ? _win[\"inner\" + d2] : scroller[\"client\" + d2]) || 0,\n\t_getOffsetsFunc = (element, isViewport) => !isViewport || ~_proxies.indexOf(element) ? _getBoundsFunc(element) : () => _winOffsets,\n\t_maxScroll = (element, {s, d2, d, a}) => (s = \"scroll\" + d2) && (a = _getProxyProp(element, s)) ? a() - _getBoundsFunc(element)()[d] : _isViewport(element) ? (_body[s] || _docEl[s]) - (_win[\"inner\" + d2] || _docEl[\"client\" + d2] || _body[\"client\" + d2]) : element[s] - element[\"offset\" + d2],\n\t_iterateAutoRefresh = (func, events) => {\n\t\tfor (let i = 0; i < _autoRefresh.length; i += 3) {\n\t\t\t(!events || ~events.indexOf(_autoRefresh[i+1])) && func(_autoRefresh[i], _autoRefresh[i+1], _autoRefresh[i+2]);\n\t\t}\n\t},\n\t_isString = value => typeof(value) === \"string\",\n\t_isFunction = value => typeof(value) === \"function\",\n\t_isNumber = value => typeof(value) === \"number\",\n\t_isObject = value => typeof(value) === \"object\",\n\t_callIfFunc = value => _isFunction(value) && value(),\n\t_combineFunc = (f1, f2) => () => {\n\t\tlet result1 = _callIfFunc(f1),\n\t\t\tresult2 = _callIfFunc(f2);\n\t\treturn () => {\n\t\t\t_callIfFunc(result1);\n\t\t\t_callIfFunc(result2);\n\t\t}\n\t},\n\t_endAnimation = (animation, reversed, pause) => animation && animation.progress(reversed ? 0 : 1) && pause && animation.pause(),\n\t_callback = (self, func) => {\n\t\tlet result = func(self);\n\t\tresult && result.totalTime && (self.callbackAnimation = result);\n\t},\n\t_abs = Math.abs,\n\t_scrollLeft = \"scrollLeft\",\n\t_scrollTop = \"scrollTop\",\n\t_left = \"left\",\n\t_top = \"top\",\n\t_right = \"right\",\n\t_bottom = \"bottom\",\n\t_width = \"width\",\n\t_height = \"height\",\n\t_Right = \"Right\",\n\t_Left = \"Left\",\n\t_Top = \"Top\",\n\t_Bottom = \"Bottom\",\n\t_padding = \"padding\",\n\t_margin = \"margin\",\n\t_Width = \"Width\",\n\t_Height = \"Height\",\n\t_px = \"px\",\n\t_horizontal = {s: _scrollLeft, p: _left, p2: _Left, os: _right, os2: _Right, d: _width, d2: _Width, a: \"x\", sc: function(value) { return arguments.length ? _win.scrollTo(value, _vertical.sc()) : _win.pageXOffset || _doc[_scrollLeft] || _docEl[_scrollLeft] || _body[_scrollLeft] || 0}},\n\t_vertical = {s: _scrollTop, p: _top, p2: _Top, os: _bottom, os2: _Bottom, d: _height, d2: _Height, a: \"y\", op: _horizontal, sc: function(value) { return arguments.length ? _win.scrollTo(_horizontal.sc(), value) : _win.pageYOffset || _doc[_scrollTop] || _docEl[_scrollTop] || _body[_scrollTop] || 0}},\n\t_getComputedStyle = element => _win.getComputedStyle(element),\n\t_makePositionable = element => { // if the element already has position: absolute or fixed, leave that, otherwise make it position: relative\n\t\tlet position = _getComputedStyle(element).position;\n\t\telement.style.position = (position === \"absolute\" || position === \"fixed\") ? position : \"relative\";\n\t},\n\t_setDefaults = (obj, defaults) => {\n\t\tfor (let p in defaults) {\n\t\t\t(p in obj) || (obj[p] = defaults[p]);\n\t\t}\n\t\treturn obj;\n\t},\n\t_getBounds = (element, withoutTransforms) => {\n\t\tlet tween = withoutTransforms && _getComputedStyle(element)[_transformProp] !== \"matrix(1, 0, 0, 1, 0, 0)\" && gsap.to(element, {x: 0, y: 0, xPercent: 0, yPercent: 0, rotation: 0, rotationX: 0, rotationY: 0, scale: 1, skewX: 0, skewY: 0}).progress(1),\n\t\t\tbounds = element.getBoundingClientRect();\n\t\ttween && tween.progress(0).kill();\n\t\treturn bounds;\n\t},\n\t_getSize = (element, {d2}) => element[\"offset\" + d2] || element[\"client\" + d2] || 0,\n\t_getLabelRatioArray = timeline => {\n\t\tlet a = [],\n\t\t\tlabels = timeline.labels,\n\t\t\tduration = timeline.duration(),\n\t\t\tp;\n\t\tfor (p in labels) {\n\t\t\ta.push(labels[p] / duration);\n\t\t}\n\t\treturn a;\n\t},\n\t_getClosestLabel = animation => value => gsap.utils.snap(_getLabelRatioArray(animation), value),\n\t_snapDirectional = snapIncrementOrArray => {\n\t\tlet snap = gsap.utils.snap(snapIncrementOrArray),\n\t\t\ta = Array.isArray(snapIncrementOrArray) && snapIncrementOrArray.slice(0).sort((a, b) => a - b);\n\t\treturn a ? (value, direction) => {\n\t\t\tlet i;\n\t\t\tif (!direction) {\n\t\t\t\treturn snap(value);\n\t\t\t}\n\t\t\tif (direction > 0) {\n\t\t\t\tvalue -= 1e-4; // to avoid rounding errors. If we're too strict, it might snap forward, then immediately again, and again.\n\t\t\t\tfor (i = 0; i < a.length; i++) {\n\t\t\t\t\tif (a[i] >= value) {\n\t\t\t\t\t\treturn a[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn a[i-1];\n\t\t\t} else {\n\t\t\t\ti = a.length;\n\t\t\t\tvalue += 1e-4;\n\t\t\t\twhile (i--) {\n\t\t\t\t\tif (a[i] <= value) {\n\t\t\t\t\t\treturn a[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn a[0];\n\t\t} : (value, direction) => {\n\t\t\tlet snapped = snap(value);\n\t\t\treturn !direction || Math.abs(snapped - value) < 0.001 || ((snapped - value < 0) === direction < 0) ? snapped : snap(direction < 0 ? value - snapIncrementOrArray : value + snapIncrementOrArray);\n\t\t};\n\t},\n\t_getLabelAtDirection = timeline => (value, st) => _snapDirectional(_getLabelRatioArray(timeline))(value, st.direction),\n\t_multiListener = (func, element, types, callback) => types.split(\",\").forEach(type => func(element, type, callback)),\n\t_addListener = (element, type, func) => element.addEventListener(type, func, {passive: true}),\n\t_removeListener = (element, type, func) => element.removeEventListener(type, func),\n\t_markerDefaults = {startColor: \"green\", endColor: \"red\", indent: 0, fontSize: \"16px\", fontWeight:\"normal\"},\n\t_defaults = {toggleActions: \"play\", anticipatePin: 0},\n\t_keywords = {top: 0, left: 0, center: 0.5, bottom: 1, right: 1},\n\t_offsetToPx = (value, size) => {\n\t\tif (_isString(value)) {\n\t\t\tlet eqIndex = value.indexOf(\"=\"),\n\t\t\t\trelative = ~eqIndex ? +(value.charAt(eqIndex-1) + 1) * parseFloat(value.substr(eqIndex + 1)) : 0;\n\t\t\tif (~eqIndex) {\n\t\t\t\t(value.indexOf(\"%\") > eqIndex) && (relative *= size / 100);\n\t\t\t\tvalue = value.substr(0, eqIndex-1);\n\t\t\t}\n\t\t\tvalue = relative + ((value in _keywords) ? _keywords[value] * size : ~value.indexOf(\"%\") ? parseFloat(value) * size / 100 : parseFloat(value) || 0);\n\t\t}\n\t\treturn value;\n\t},\n\t_createMarker = (type, name, container, direction, {startColor, endColor, fontSize, indent, fontWeight}, offset, matchWidthEl, containerAnimation) => {\n\t\tlet e = _doc.createElement(\"div\"),\n\t\t\tuseFixedPosition = _isViewport(container) || _getProxyProp(container, \"pinType\") === \"fixed\",\n\t\t\tisScroller = type.indexOf(\"scroller\") !== -1,\n\t\t\tparent = useFixedPosition ? _body : container,\n\t\t\tisStart = type.indexOf(\"start\") !== -1,\n\t\t\tcolor = isStart ? startColor : endColor,\n\t\t\tcss = \"border-color:\" + color + \";font-size:\" + fontSize + \";color:\" + color + \";font-weight:\" + fontWeight + \";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;\";\n\t\tcss += \"position:\" + ((isScroller || containerAnimation) && useFixedPosition ? \"fixed;\" : \"absolute;\");\n\t\t(isScroller || containerAnimation || !useFixedPosition) && (css += (direction === _vertical ? _right : _bottom) + \":\" + (offset + parseFloat(indent)) + \"px;\");\n\t\tmatchWidthEl && (css += \"box-sizing:border-box;text-align:left;width:\" + matchWidthEl.offsetWidth + \"px;\");\n\t\te._isStart = isStart;\n\t\te.setAttribute(\"class\", \"gsap-marker-\" + type + (name ? \" marker-\" + name : \"\"));\n\t\te.style.cssText = css;\n\t\te.innerText = name || name === 0 ? type + \"-\" + name : type;\n\t\tparent.children[0] ? parent.insertBefore(e, parent.children[0]) : parent.appendChild(e);\n\t\te._offset = e[\"offset\" + direction.op.d2];\n\t\t_positionMarker(e, 0, direction, isStart);\n\t\treturn e;\n\t},\n\t_positionMarker = (marker, start, direction, flipped) => {\n\t\tlet vars = {display: \"block\"},\n\t\t\tside = direction[flipped ? \"os2\" : \"p2\"],\n\t\t\toppositeSide = direction[flipped ? \"p2\" : \"os2\"];\n\t\tmarker._isFlipped = flipped;\n\t\tvars[direction.a + \"Percent\"] = flipped ? -100 : 0;\n\t\tvars[direction.a] = flipped ? \"1px\" : 0;\n\t\tvars[\"border\" + side + _Width] = 1;\n\t\tvars[\"border\" + oppositeSide + _Width] = 0;\n\t\tvars[direction.p] = start + \"px\";\n\t\tgsap.set(marker, vars);\n\t},\n\t_triggers = [],\n\t_ids = {},\n\t_sync = () => _getTime() - _lastScrollTime > 20 && _updateAll(),\n\t_onScroll = () => {\n\t\tlet time = _getTime();\n\t\tif (_lastScrollTime !== time) {\n\t\t\t_updateAll();\n\t\t\t_lastScrollTime || _dispatch(\"scrollStart\");\n\t\t\t_lastScrollTime = time;\n\t\t} else if (!_request) {\n\t\t\t_request = _raf(_updateAll);\n\t\t}\n\t},\n\t_onResize = () => !_refreshing && !_ignoreResize && !_doc.fullscreenElement && _resizeDelay.restart(true), // ignore resizes triggered by refresh()\n\t_listeners = {},\n\t_emptyArray = [],\n\t_media = [],\n\t_creatingMedia, // when ScrollTrigger.matchMedia() is called, we record the current media key here (like \"(min-width: 800px)\") so that we can assign it to everything that's created during that call. Then we can revert just those when necessary. In the ScrollTrigger's init() call, the _creatingMedia is recorded as a \"media\" property on the instance.\n\t_lastMediaTick,\n\t_onMediaChange = e => {\n\t\tlet tick = gsap.ticker.frame,\n\t\t\tmatches = [],\n\t\t\ti = 0,\n\t\t\tindex;\n\t\tif (_lastMediaTick !== tick || _startup) {\n\t\t\t_revertAll();\n\t\t\tfor (; i < _media.length; i+=4) {\n\t\t\t\tindex = _win.matchMedia(_media[i]).matches;\n\t\t\t\tif (index !== _media[i+3]) { // note: some browsers fire the matchMedia event multiple times, like when going full screen, so we shouldn't call the function multiple times. Check to see if it's already matched.\n\t\t\t\t\t_media[i+3] = index;\n\t\t\t\t\tindex ? matches.push(i) : _revertAll(1, _media[i]) || (_isFunction(_media[i+2]) && _media[i+2]()); // Firefox doesn't update the \"matches\" property of the MediaQueryList object correctly - it only does so as it calls its change handler - so we must re-create a media query here to ensure it's accurate.\n\t\t\t\t}\n\t\t\t}\n\t\t\t_revertRecorded(); // in case killing/reverting any of the animations actually added inline styles back.\n\t\t\tfor (i = 0; i < matches.length; i++) {\n\t\t\t\tindex = matches[i];\n\t\t\t\t_creatingMedia = _media[index];\n\t\t\t\t_media[index+2] = _media[index+1](e);\n\t\t\t}\n\t\t\t_creatingMedia = 0;\n\t\t\t_coreInitted && _refreshAll(0, 1);\n\t\t\t_lastMediaTick = tick;\n\t\t\t_dispatch(\"matchMedia\");\n\t\t}\n\t},\n\t_softRefresh = () => _removeListener(ScrollTrigger, \"scrollEnd\", _softRefresh) || _refreshAll(true),\n\t_dispatch = type => (_listeners[type] && _listeners[type].map(f => f())) || _emptyArray,\n\t_savedStyles = [], // when ScrollTrigger.saveStyles() is called, the inline styles are recorded in this Array in a sequential format like [element, cssText, gsCache, media]. This keeps it very memory-efficient and fast to iterate through.\n\t_revertRecorded = media => {\n\t\tfor (let i = 0; i < _savedStyles.length; i+=5) {\n\t\t\tif (!media || _savedStyles[i+4] === media) {\n\t\t\t\t_savedStyles[i].style.cssText = _savedStyles[i+1];\n\t\t\t\t_savedStyles[i].getBBox && _savedStyles[i].setAttribute(\"transform\", _savedStyles[i+2] || \"\");\n\t\t\t\t_savedStyles[i+3].uncache = 1;\n\t\t\t}\n\t\t}\n\t},\n\t_revertAll = (kill, media) => {\n\t\tlet trigger;\n\t\tfor (_i = 0; _i < _triggers.length; _i++) {\n\t\t\ttrigger = _triggers[_i];\n\t\t\tif (!media || trigger.media === media) {\n\t\t\t\tif (kill) {\n\t\t\t\t\ttrigger.kill(1);\n\t\t\t\t} else {\n\t\t\t\t\ttrigger.revert();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmedia && _revertRecorded(media);\n\t\tmedia || _dispatch(\"revert\");\n\t},\n\t_clearScrollMemory = () => _scrollers.forEach(obj => typeof(obj) === \"function\" && (obj.rec = 0)), // zero-out all the recorded scroll positions. Don't use _triggers because if, for example, .matchMedia() is used to create some ScrollTriggers and then the user resizes and it removes ALL ScrollTriggers, and then go back to a size where there are ScrollTriggers, it would have kept the position(s) saved from the initial state.\n\t_refreshingAll,\n\t_refreshAll = (force, skipRevert) => {\n\t\tif (_lastScrollTime && !force) {\n\t\t\t_addListener(ScrollTrigger, \"scrollEnd\", _softRefresh);\n\t\t\treturn;\n\t\t}\n\t\t_refreshingAll = true;\n\t\tlet refreshInits = _dispatch(\"refreshInit\");\n\t\t_sort && ScrollTrigger.sort();\n\t\tskipRevert || _revertAll();\n\t\t_triggers.forEach(t => t.refresh()) // don't loop with _i because during a refresh() someone could call ScrollTrigger.update() which would iterate through _i resulting in a skip.\n\t\trefreshInits.forEach(result => result && result.render && result.render(-1)); // if the onRefreshInit() returns an animation (typically a gsap.set()), revert it. This makes it easy to put things in a certain spot before refreshing for measurement purposes, and then put things back.\n\t\t_clearScrollMemory();\n\t\t_resizeDelay.pause();\n\t\t_refreshingAll = false;\n\t\t_dispatch(\"refresh\");\n\t},\n\t_lastScroll = 0,\n\t_direction = 1,\n\t_updateAll = () => {\n\t\tif (!_refreshingAll) {\n\t\t\tlet l = _triggers.length,\n\t\t\t\ttime = _getTime(),\n\t\t\t\trecordVelocity = time - _time1 >= 50,\n\t\t\t\tscroll = l && _triggers[0].scroll();\n\t\t\t_direction = _lastScroll > scroll ? -1 : 1;\n\t\t\t_lastScroll = scroll;\n\t\t\tif (recordVelocity) {\n\t\t\t\tif (_lastScrollTime && !_pointerIsDown && time - _lastScrollTime > 200) {\n\t\t\t\t\t_lastScrollTime = 0;\n\t\t\t\t\t_dispatch(\"scrollEnd\");\n\t\t\t\t}\n\t\t\t\t_time2 = _time1;\n\t\t\t\t_time1 = time;\n\t\t\t}\n\t\t\tif (_direction < 0) {\n\t\t\t\t_i = l;\n\t\t\t\twhile (_i-- > 0) {\n\t\t\t\t\t_triggers[_i] && _triggers[_i].update(0, recordVelocity);\n\t\t\t\t}\n\t\t\t\t_direction = 1;\n\t\t\t} else {\n\t\t\t\tfor (_i = 0; _i < l; _i++) {\n\t\t\t\t\t_triggers[_i] && _triggers[_i].update(0, recordVelocity);\n\t\t\t\t}\n\t\t\t}\n\t\t\t_request = 0;\n\t\t}\n\t},\n\t_propNamesToCopy = [_left, _top, _bottom, _right, _margin + _Bottom, _margin + _Right, _margin + _Top, _margin + _Left, \"display\", \"flexShrink\", \"float\", \"zIndex\", \"grid-column-start\", \"grid-column-end\", \"grid-row-start\", \"grid-row-end\", \"grid-area\", \"justify-self\", \"align-self\", \"place-self\"],\n\t_stateProps = _propNamesToCopy.concat([_width, _height, \"boxSizing\", \"max\" + _Width, \"max\" + _Height, \"position\", _margin, _padding, _padding + _Top, _padding + _Right, _padding + _Bottom, _padding + _Left]),\n\t_swapPinOut = (pin, spacer, state) => {\n\t\t_setState(state);\n\t\tlet cache = pin._gsap;\n\t\tif (cache.spacerIsNative) {\n\t\t\t_setState(cache.spacerState);\n\t\t} else if (pin.parentNode === spacer) {\n\t\t\tlet parent = spacer.parentNode;\n\t\t\tif (parent) {\n\t\t\t\tparent.insertBefore(pin, spacer);\n\t\t\t\tparent.removeChild(spacer);\n\t\t\t}\n\t\t}\n\t},\n\t_swapPinIn = (pin, spacer, cs, spacerState) => {\n\t\tif (pin.parentNode !== spacer) {\n\t\t\tlet i = _propNamesToCopy.length,\n\t\t\t\tspacerStyle = spacer.style,\n\t\t\t\tpinStyle = pin.style,\n\t\t\t\tp;\n\t\t\twhile (i--) {\n\t\t\t\tp = _propNamesToCopy[i];\n\t\t\t\tspacerStyle[p] = cs[p];\n\t\t\t}\n\t\t\tspacerStyle.position = cs.position === \"absolute\" ? \"absolute\" : \"relative\";\n\t\t\t(cs.display === \"inline\") && (spacerStyle.display = \"inline-block\");\n\t\t\tpinStyle[_bottom] = pinStyle[_right] = \"auto\";\n\t\t\tspacerStyle.overflow = \"visible\";\n\t\t\tspacerStyle.boxSizing = \"border-box\";\n\t\t\tspacerStyle[_width] = _getSize(pin, _horizontal) + _px;\n\t\t\tspacerStyle[_height] = _getSize(pin, _vertical) + _px;\n\t\t\tspacerStyle[_padding] = pinStyle[_margin] = pinStyle[_top] = pinStyle[_left] = \"0\";\n\t\t\t_setState(spacerState);\n\t\t\tpinStyle[_width] = pinStyle[\"max\" + _Width] = cs[_width];\n\t\t\tpinStyle[_height] = pinStyle[\"max\" + _Height] = cs[_height];\n\t\t\tpinStyle[_padding] = cs[_padding];\n\t\t\tpin.parentNode.insertBefore(spacer, pin);\n\t\t\tspacer.appendChild(pin);\n\t\t}\n\t},\n\t_capsExp = /([A-Z])/g,\n\t_setState = state => {\n\t\tif (state) {\n\t\t\tlet style = state.t.style,\n\t\t\t\tl = state.length,\n\t\t\t\ti = 0,\n\t\t\t\tp, value;\n\t\t\t(state.t._gsap || gsap.core.getCache(state.t)).uncache = 1; // otherwise transforms may be off\n\t\t\tfor (; i < l; i +=2) {\n\t\t\t\tvalue = state[i+1];\n\t\t\t\tp = state[i];\n\t\t\t\tif (value) {\n\t\t\t\t\tstyle[p] = value;\n\t\t\t\t} else if (style[p]) {\n\t\t\t\t\tstyle.removeProperty(p.replace(_capsExp, \"-$1\").toLowerCase());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\t_getState = element => { // returns an Array with alternating values like [property, value, property, value] and a \"t\" property pointing to the target (element). Makes it fast and cheap.\n\t\tlet l = _stateProps.length,\n\t\t\tstyle = element.style,\n\t\t\tstate = [],\n\t\t\ti = 0;\n\t\tfor (; i < l; i++) {\n\t\t\tstate.push(_stateProps[i], style[_stateProps[i]]);\n\t\t}\n\t\tstate.t = element;\n\t\treturn state;\n\t},\n\t_copyState = (state, override, omitOffsets) => {\n\t\tlet result = [],\n\t\t\tl = state.length,\n\t\t\ti = omitOffsets ? 8 : 0, // skip top, left, right, bottom if omitOffsets is true\n\t\t\tp;\n\t\tfor (; i < l; i += 2) {\n\t\t\tp = state[i];\n\t\t\tresult.push(p, (p in override) ? override[p] : state[i+1]);\n\t\t}\n\t\tresult.t = state.t;\n\t\treturn result;\n\t},\n\t_winOffsets = {left:0, top:0},\n\t// // potential future feature (?) Allow users to calculate where a trigger hits (scroll position) like getScrollPosition(\"#id\", \"top bottom\")\n\t// _getScrollPosition = (trigger, position, {scroller, containerAnimation, horizontal}) => {\n\t// \tscroller = _getTarget(scroller || _win);\n\t// \tlet direction = horizontal ? _horizontal : _vertical,\n\t// \t\tisViewport = _isViewport(scroller);\n\t// \t_getSizeFunc(scroller, isViewport, direction);\n\t// \treturn _parsePosition(position, _getTarget(trigger), _getSizeFunc(scroller, isViewport, direction)(), direction, _getScrollFunc(scroller, direction)(), 0, 0, 0, _getOffsetsFunc(scroller, isViewport)(), isViewport ? 0 : parseFloat(_getComputedStyle(scroller)[\"border\" + direction.p2 + _Width]) || 0, 0, containerAnimation ? containerAnimation.duration() : _maxScroll(scroller), containerAnimation);\n\t// },\n\t_parsePosition = (value, trigger, scrollerSize, direction, scroll, marker, markerScroller, self, scrollerBounds, borderWidth, useFixedPosition, scrollerMax, containerAnimation) => {\n\t\t_isFunction(value) && (value = value(self));\n\t\tif (_isString(value) && value.substr(0,3) === \"max\") {\n\t\t\tvalue = scrollerMax + (value.charAt(4) === \"=\" ? _offsetToPx(\"0\" + value.substr(3), scrollerSize) : 0);\n\t\t}\n\t\tlet time = containerAnimation ? containerAnimation.time() : 0,\n\t\t\tp1, p2, element;\n\t\tcontainerAnimation && containerAnimation.seek(0);\n\t\tif (!_isNumber(value)) {\n\t\t\t_isFunction(trigger) && (trigger = trigger(self));\n\t\t\tlet offsets = value.split(\" \"),\n\t\t\t\tbounds, localOffset, globalOffset, display;\n\t\t\telement = _getTarget(trigger) || _body;\n\t\t\tbounds = _getBounds(element) || {};\n\t\t\tif ((!bounds || (!bounds.left && !bounds.top)) && _getComputedStyle(element).display === \"none\") { // if display is \"none\", it won't report getBoundingClientRect() properly\n\t\t\t\tdisplay = element.style.display;\n\t\t\t\telement.style.display = \"block\";\n\t\t\t\tbounds = _getBounds(element);\n\t\t\t\tdisplay ? (element.style.display = display) : element.style.removeProperty(\"display\");\n\t\t\t}\n\t\t\tlocalOffset = _offsetToPx(offsets[0], bounds[direction.d]);\n\t\t\tglobalOffset = _offsetToPx(offsets[1] || \"0\", scrollerSize);\n\t\t\tvalue = bounds[direction.p] - scrollerBounds[direction.p] - borderWidth + localOffset + scroll - globalOffset;\n\t\t\tmarkerScroller && _positionMarker(markerScroller, globalOffset, direction, (scrollerSize - globalOffset < 20 || (markerScroller._isStart && globalOffset > 20)));\n\t\t\tscrollerSize -= scrollerSize - globalOffset; // adjust for the marker\n\t\t} else if (markerScroller) {\n\t\t\t_positionMarker(markerScroller, scrollerSize, direction, true);\n\t\t}\n\t\tif (marker) {\n\t\t\tlet position = value + scrollerSize,\n\t\t\t\tisStart = marker._isStart;\n\t\t\tp1 = \"scroll\" + direction.d2;\n\t\t\t_positionMarker(marker, position, direction, (isStart && position > 20) || (!isStart && (useFixedPosition ? Math.max(_body[p1], _docEl[p1]) : marker.parentNode[p1]) <= position + 1));\n\t\t\tif (useFixedPosition) {\n\t\t\t\tscrollerBounds = _getBounds(markerScroller);\n\t\t\t\tuseFixedPosition && (marker.style[direction.op.p] = (scrollerBounds[direction.op.p] - direction.op.m - marker._offset) + _px);\n\t\t\t}\n\t\t}\n\t\tif (containerAnimation && element) {\n\t\t\tp1 = _getBounds(element);\n\t\t\tcontainerAnimation.seek(scrollerMax);\n\t\t\tp2 = _getBounds(element);\n\t\t\tcontainerAnimation._caScrollDist = p1[direction.p] - p2[direction.p];\n\t\t\tvalue = value / (containerAnimation._caScrollDist) * scrollerMax;\n\t\t}\n\t\tcontainerAnimation && containerAnimation.seek(time);\n\t\treturn containerAnimation ? value : Math.round(value);\n\t},\n\t_prefixExp = /(?:webkit|moz|length|cssText|inset)/i,\n\t_reparent = (element, parent, top, left) => {\n\t\tif (element.parentNode !== parent) {\n\t\t\tlet style = element.style,\n\t\t\t\tp, cs;\n\t\t\tif (parent === _body) {\n\t\t\t\telement._stOrig = style.cssText; // record original inline styles so we can revert them later\n\t\t\t\tcs = _getComputedStyle(element);\n\t\t\t\tfor (p in cs) { // must copy all relevant styles to ensure that nothing changes visually when we reparent to the <body>. Skip the vendor prefixed ones.\n\t\t\t\t\tif (!+p && !_prefixExp.test(p) && cs[p] && typeof style[p] === \"string\" && p !== \"0\") {\n\t\t\t\t\t\tstyle[p] = cs[p];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstyle.top = top;\n\t\t\t\tstyle.left = left;\n\t\t\t} else {\n\t\t\t\tstyle.cssText = element._stOrig;\n\t\t\t}\n\t\t\tgsap.core.getCache(element).uncache = 1;\n\t\t\tparent.appendChild(element);\n\t\t}\n\t},\n\t// _mergeAnimations = animations => {\n\t// \tlet tl = gsap.timeline({smoothChildTiming: true}).startTime(Math.min(...animations.map(a => a.globalTime(0))));\n\t// \tanimations.forEach(a => {let time = a.totalTime(); tl.add(a); a.totalTime(time); });\n\t// \ttl.smoothChildTiming = false;\n\t// \treturn tl;\n\t// },\n\n\t// returns a function that can be used to tween the scroll position in the direction provided, and when doing so it'll add a .tween property to the FUNCTION itself, and remove it when the tween completes or gets killed. This gives us a way to have multiple ScrollTriggers use a central function for any given scroller and see if there's a scroll tween running (which would affect if/how things get updated)\n\t_getTweenCreator = (scroller, direction) => {\n\t\tlet getScroll = _getScrollFunc(scroller, direction),\n\t\t\tprop = \"_scroll\" + direction.p2, // add a tweenable property to the scroller that's a getter/setter function, like _scrollTop or _scrollLeft. This way, if someone does gsap.killTweensOf(scroller) it'll kill the scroll tween.\n\t\t\tlastScroll1, lastScroll2,\n\t\t\tgetTween = (scrollTo, vars, initialValue, change1, change2) => {\n\t\t\t\tlet tween = getTween.tween,\n\t\t\t\t\tonComplete = vars.onComplete,\n\t\t\t\t\tmodifiers = {};\n\t\t\t\ttween && tween.kill();\n\t\t\t\tlastScroll1 = Math.round(initialValue);\n\t\t\t\tvars[prop] = scrollTo;\n\t\t\t\tvars.modifiers = modifiers;\n\t\t\t\tmodifiers[prop] = value => {\n\t\t\t\t\tvalue = _round(getScroll()); // round because in some [very uncommon] Windows environments, it can get reported with decimals even though it was set without.\n\t\t\t\t\tif (value !== lastScroll1 && value !== lastScroll2 && Math.abs(value - lastScroll1) > 2) { // if the user scrolls, kill the tween. iOS Safari intermittently misreports the scroll position, it may be the most recently-set one or the one before that! When Safari is zoomed (CMD-+), it often misreports as 1 pixel off too! So if we set the scroll position to 125, for example, it'll actually report it as 124.\n\t\t\t\t\t\ttween.kill();\n\t\t\t\t\t\tgetTween.tween = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvalue = initialValue + change1 * tween.ratio + change2 * tween.ratio * tween.ratio;\n\t\t\t\t\t}\n\t\t\t\t\tlastScroll2 = lastScroll1;\n\t\t\t\t\treturn (lastScroll1 = _round(value));\n\t\t\t\t};\n\t\t\t\tvars.onComplete = () => {\n\t\t\t\t\tgetTween.tween = 0;\n\t\t\t\t\tonComplete && onComplete.call(tween);\n\t\t\t\t};\n\t\t\t\ttween = getTween.tween = gsap.to(scroller, vars);\n\t\t\t\treturn tween;\n\t\t\t};\n\t\tscroller[prop] = getScroll;\n\t\tscroller.addEventListener(\"wheel\", () => getTween.tween && getTween.tween.kill() && (getTween.tween = 0), {passive: true}); // Windows machines handle mousewheel scrolling in chunks (like \"3 lines per scroll\") meaning the typical strategy for cancelling the scroll isn't as sensitive. It's much more likely to match one of the previous 2 scroll event positions. So we kill any snapping as soon as there's a wheel event.\n\t\treturn getTween;\n\t};\n\n_horizontal.op = _vertical;\n\n\n\nexport class ScrollTrigger {\n\n\tconstructor(vars, animation) {\n\t\t_coreInitted || ScrollTrigger.register(gsap) || console.warn(\"Please gsap.registerPlugin(ScrollTrigger)\");\n\t\tthis.init(vars, animation);\n\t}\n\n\tinit(vars, animation) {\n\t\tthis.progress = this.start = 0;\n\t\tthis.vars && this.kill(1); // in case it's being initted again\n\t\tif (!_enabled) {\n\t\t\tthis.update = this.refresh = this.kill = _passThrough;\n\t\t\treturn;\n\t\t}\n\t\tvars = _setDefaults((_isString(vars) || _isNumber(vars) || vars.nodeType) ? {trigger: vars} : vars, _defaults);\n\t\tlet {onUpdate, toggleClass, id, onToggle, onRefresh, scrub, trigger, pin, pinSpacing, invalidateOnRefresh, anticipatePin, onScrubComplete, onSnapComplete, once, snap, pinReparent, pinSpacer, containerAnimation, fastScrollEnd, preventOverlaps} = vars,\n\t\t\tdirection = vars.horizontal || (vars.containerAnimation && vars.horizontal !== false) ? _horizontal : _vertical,\n\t\t\tisToggle = !scrub && scrub !== 0,\n\t\t\tscroller = _getTarget(vars.scroller || _win),\n\t\t\tscrollerCache = gsap.core.getCache(scroller),\n\t\t\tisViewport = _isViewport(scroller),\n\t\t\tuseFixedPosition = (\"pinType\" in vars ? vars.pinType : _getProxyProp(scroller, \"pinType\") || (isViewport && \"fixed\")) === \"fixed\",\n\t\t\tcallbacks = [vars.onEnter, vars.onLeave, vars.onEnterBack, vars.onLeaveBack],\n\t\t\ttoggleActions = isToggle && vars.toggleActions.split(\" \"),\n\t\t\tmarkers = \"markers\" in vars ? vars.markers : _defaults.markers,\n\t\t\tborderWidth = isViewport ? 0 : parseFloat(_getComputedStyle(scroller)[\"border\" + direction.p2 + _Width]) || 0,\n\t\t\tself = this,\n\t\t\tonRefreshInit = vars.onRefreshInit && (() => vars.onRefreshInit(self)),\n\t\t\tgetScrollerSize = _getSizeFunc(scroller, isViewport, direction),\n\t\t\tgetScrollerOffsets = _getOffsetsFunc(scroller, isViewport),\n\t\t\tlastSnap = 0,\n\t\t\tscrollFunc = _getScrollFunc(scroller, direction),\n\t\t\ttweenTo, pinCache, snapFunc, scroll1, scroll2, start, end, markerStart, markerEnd, markerStartTrigger, markerEndTrigger, markerVars,\n\t\t\tchange, pinOriginalState, pinActiveState, pinState, spacer, offset, pinGetter, pinSetter, pinStart, pinChange, spacingStart, spacerState, markerStartSetter,\n\t\t\tmarkerEndSetter, cs, snap1, snap2, scrubTween, scrubSmooth, snapDurClamp, snapDelayedCall, prevProgress, prevScroll, prevAnimProgress, caMarkerSetter;\n\n\t\tself.media = _creatingMedia;\n\t\tanticipatePin *= 45;\n\t\tself.scroller = scroller;\n\t\tself.scroll = containerAnimation ? containerAnimation.time.bind(containerAnimation) : scrollFunc;\n\t\tscroll1 = scrollFunc();\n\t\tself.vars = vars;\n\t\tanimation = animation || vars.animation;\n\t\t(\"refreshPriority\" in vars) && (_sort = 1);\n\t\tscrollerCache.tweenScroll = scrollerCache.tweenScroll || {\n\t\t\ttop: _getTweenCreator(scroller, _vertical),\n\t\t\tleft: _getTweenCreator(scroller, _horizontal)\n\t\t};\n\t\tself.tweenTo = tweenTo = scrollerCache.tweenScroll[direction.p];\n\t\tif (animation) {\n\t\t\tanimation.vars.lazy = false;\n\t\t\tanimation._initted || (animation.vars.immediateRender !== false && vars.immediateRender !== false && animation.render(0, true, true));\n\t\t\tself.animation = animation.pause();\n\t\t\tanimation.scrollTrigger = self;\n\t\t\tscrubSmooth = _isNumber(scrub) && scrub;\n\t\t\tscrubSmooth && (scrubTween = gsap.to(animation, {ease: \"power3\", duration: scrubSmooth, onComplete: () => onScrubComplete && onScrubComplete(self)}));\n\t\t\tsnap1 = 0;\n\t\t\tid || (id = animation.vars.id);\n\t\t}\n\t\t_triggers.push(self);\n\t\tif (snap) {\n\t\t\tif (!_isObject(snap) || snap.push) {\n\t\t\t\tsnap = {snapTo: snap};\n\t\t\t}\n\t\t\t(\"scrollBehavior\" in _body.style) && gsap.set(isViewport ? [_body, _docEl] : scroller, {scrollBehavior: \"auto\"}); // smooth scrolling doesn't work with snap.\n\t\t\tsnapFunc = _isFunction(snap.snapTo) ? snap.snapTo : snap.snapTo === \"labels\" ? _getClosestLabel(animation) : snap.snapTo === \"labelsDirectional\" ? _getLabelAtDirection(animation) : snap.directional !== false ? (value, st) => _snapDirectional(snap.snapTo)(value, st.direction) : gsap.utils.snap(snap.snapTo);\n\t\t\tsnapDurClamp = snap.duration || {min: 0.1, max: 2};\n\t\t\tsnapDurClamp = _isObject(snapDurClamp) ? _clamp(snapDurClamp.min, snapDurClamp.max) : _clamp(snapDurClamp, snapDurClamp);\n\t\t\tsnapDelayedCall = gsap.delayedCall(snap.delay || (scrubSmooth / 2) || 0.1, () => {\n\t\t\t\tif (Math.abs(self.getVelocity()) < 10 && !_pointerIsDown && lastSnap !== scrollFunc()) {\n\t\t\t\t\tlet totalProgress = animation && !isToggle ? animation.totalProgress() : self.progress,\n\t\t\t\t\t\tvelocity = ((totalProgress - snap2) / (_getTime() - _time2) * 1000) || 0,\n\t\t\t\t\t\tchange1 = gsap.utils.clamp(-self.progress, 1 - self.progress, _abs(velocity / 2) * velocity / 0.185),\n\t\t\t\t\t\tnaturalEnd = self.progress + (snap.inertia === false ? 0 : change1),\n\t\t\t\t\t\tendValue = _clamp(0, 1, snapFunc(naturalEnd, self)),\n\t\t\t\t\t\tscroll = scrollFunc(),\n\t\t\t\t\t\tendScroll = Math.round(start + endValue * change),\n\t\t\t\t\t\t{ onStart, onInterrupt, onComplete } = snap,\n\t\t\t\t\t\ttween = tweenTo.tween;\n\t\t\t\t\tif (scroll <= end && scroll >= start && endScroll !== scroll) {\n\t\t\t\t\t\tif (tween && !tween._initted && tween.data <= _abs(endScroll - scroll)) { // there's an overlapping snap! So we must figure out which one is closer and let that tween live.\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (snap.inertia === false) {\n\t\t\t\t\t\t\tchange1 = endValue - self.progress;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttweenTo(endScroll, {\n\t\t\t\t\t\t\tduration: snapDurClamp(_abs( (Math.max(_abs(naturalEnd - totalProgress), _abs(endValue - totalProgress)) * 0.185 / velocity / 0.05) || 0)),\n\t\t\t\t\t\t\tease: snap.ease || \"power3\",\n\t\t\t\t\t\t\tdata: _abs(endScroll - scroll), // record the distance so that if another snap tween occurs (conflict) we can prioritize the closest snap.\n\t\t\t\t\t\t\tonInterrupt: () => snapDelayedCall.restart(true) && onInterrupt && onInterrupt(self),\n\t\t\t\t\t\t\tonComplete: () => {\n\t\t\t\t\t\t\t\tlastSnap = scrollFunc();\n\t\t\t\t\t\t\t\tsnap1 = snap2 = animation && !isToggle ? animation.totalProgress() : self.progress;\n\t\t\t\t\t\t\t\tonSnapComplete && onSnapComplete(self);\n\t\t\t\t\t\t\t\tonComplete && onComplete(self);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}, scroll, change1 * change, endScroll - scroll - change1 * change);\n\t\t\t\t\t\tonStart && onStart(self, tweenTo.tween);\n\t\t\t\t\t}\n\t\t\t\t} else if (self.isActive) {\n\t\t\t\t\tsnapDelayedCall.restart(true);\n\t\t\t\t}\n\t\t\t}).pause();\n\t\t}\n\t\tid && (_ids[id] = self);\n\t\ttrigger = self.trigger = _getTarget(trigger || pin);\n\t\tpin = pin === true ? trigger : _getTarget(pin);\n\t\t_isString(toggleClass) && (toggleClass = {targets: trigger, className: toggleClass});\n\t\tif (pin) {\n\t\t\t(pinSpacing === false || pinSpacing === _margin) || (pinSpacing = !pinSpacing && _getComputedStyle(pin.parentNode).display === \"flex\" ? false : _padding); // if the parent is display: flex, don't apply pinSpacing by default.\n\t\t\tself.pin = pin;\n\t\t\tvars.force3D !== false && gsap.set(pin, {force3D: true});\n\t\t\tpinCache = gsap.core.getCache(pin);\n\t\t\tif (!pinCache.spacer) { // record the spacer and pinOriginalState on the cache in case someone tries pinning the same element with MULTIPLE ScrollTriggers - we don't want to have multiple spacers or record the \"original\" pin state after it has already been affected by another ScrollTrigger.\n\t\t\t\tif (pinSpacer) {\n\t\t\t\t\tpinSpacer = _getTarget(pinSpacer);\n\t\t\t\t\tpinSpacer && !pinSpacer.nodeType && (pinSpacer = pinSpacer.current || pinSpacer.nativeElement); // for React & Angular\n\t\t\t\t\tpinCache.spacerIsNative = !!pinSpacer;\n\t\t\t\t\tpinSpacer && (pinCache.spacerState = _getState(pinSpacer));\n\t\t\t\t}\n\t\t\t\tpinCache.spacer = spacer = pinSpacer || _doc.createElement(\"div\");\n\t\t\t\tspacer.classList.add(\"pin-spacer\");\n\t\t\t\tid && spacer.classList.add(\"pin-spacer-\" + id);\n\t\t\t\tpinCache.pinState = pinOriginalState = _getState(pin);\n\t\t\t} else {\n\t\t\t\tpinOriginalState = pinCache.pinState;\n\t\t\t}\n\t\t\tself.spacer = spacer = pinCache.spacer;\n\t\t\tcs = _getComputedStyle(pin);\n\t\t\tspacingStart = cs[pinSpacing + direction.os2];\n\t\t\tpinGetter = gsap.getProperty(pin);\n\t\t\tpinSetter = gsap.quickSetter(pin, direction.a, _px);\n\t\t\t// pin.firstChild && !_maxScroll(pin, direction) && (pin.style.overflow = \"hidden\"); // protects from collapsing margins, but can have unintended consequences as demonstrated here: https://codepen.io/GreenSock/pen/1e42c7a73bfa409d2cf1e184e7a4248d so it was removed in favor of just telling people to set up their CSS to avoid the collapsing margins (overflow: hidden | auto is just one option. Another is border-top: 1px solid transparent).\n\t\t\t_swapPinIn(pin, spacer, cs);\n\t\t\tpinState = _getState(pin);\n\t\t}\n\t\tif (markers) {\n\t\t\tmarkerVars = _isObject(markers) ? _setDefaults(markers, _markerDefaults) : _markerDefaults;\n\t\t\tmarkerStartTrigger = _createMarker(\"scroller-start\", id, scroller, direction, markerVars, 0);\n\t\t\tmarkerEndTrigger = _createMarker(\"scroller-end\", id, scroller, direction, markerVars, 0, markerStartTrigger);\n\t\t\toffset = markerStartTrigger[\"offset\" + direction.op.d2];\n\t\t\tmarkerStart = _createMarker(\"start\", id, scroller, direction, markerVars, offset, 0, containerAnimation);\n\t\t\tmarkerEnd =_createMarker(\"end\", id, scroller, direction, markerVars, offset, 0, containerAnimation);\n\t\t\tcontainerAnimation && (caMarkerSetter = gsap.quickSetter([markerStart, markerEnd], direction.a, _px));\n\t\t\tif ((!useFixedPosition && !(_proxies.length && _getProxyProp(scroller, \"fixedMarkers\") === true))) {\n\t\t\t\t_makePositionable(isViewport ? _body : scroller);\n\t\t\t\tgsap.set([markerStartTrigger, markerEndTrigger], {force3D: true});\n\t\t\t\tmarkerStartSetter = gsap.quickSetter(markerStartTrigger, direction.a, _px);\n\t\t\t\tmarkerEndSetter = gsap.quickSetter(markerEndTrigger, direction.a, _px);\n\t\t\t}\n\t\t}\n\n\t\tif (containerAnimation) {\n\t\t\tlet oldOnUpdate = containerAnimation.vars.onUpdate,\n\t\t\t\toldParams = containerAnimation.vars.onUpdateParams;\n\t\t\tcontainerAnimation.eventCallback(\"onUpdate\", () => {\n\t\t\t\tself.update(0, 0, 1);\n\t\t\t\toldOnUpdate && oldOnUpdate.apply(oldParams || []);\n\t\t\t});\n\t\t}\n\n\t\tself.previous = () => _triggers[_triggers.indexOf(self) - 1];\n\t\tself.next = () => _triggers[_triggers.indexOf(self) + 1];\n\n\t\tself.revert = revert => {\n\t\t\tlet r = revert !== false || !self.enabled,\n\t\t\t\tprevRefreshing = _refreshing;\n\t\t\tif (r !== self.isReverted) {\n\t\t\t\tif (r) {\n\t\t\t\t\tself.scroll.rec || (self.scroll.rec = scrollFunc());\n\t\t\t\t\tprevScroll = Math.max(scrollFunc(), self.scroll.rec || 0); // record the scroll so we can revert later (repositioning/pinning things can affect scroll position). In the static refresh() method, we first record all the scroll positions as a reference.\n\t\t\t\t\tprevProgress = self.progress;\n\t\t\t\t\tprevAnimProgress = animation && animation.progress();\n\t\t\t\t}\n\t\t\t\tmarkerStart && [markerStart, markerEnd, markerStartTrigger, markerEndTrigger].forEach(m => m.style.display = r ? \"none\" : \"block\");\n\t\t\t\tr && (_refreshing = 1);\n\t\t\t\tself.update(r); // make sure the pin is back in its original position so that all the measurements are correct.\n\t\t\t\t_refreshing = prevRefreshing;\n\t\t\t\tpin && (r ? _swapPinOut(pin, spacer, pinOriginalState) : (!pinReparent || !self.isActive) && _swapPinIn(pin, spacer, _getComputedStyle(pin), spacerState));\n\t\t\t\tself.isReverted = r;\n\t\t\t}\n\t\t}\n\n\n\t\tself.refresh = (soft, force) => {\n\t\t\tif ((_refreshing || !self.enabled) && !force) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (pin && soft && _lastScrollTime) {\n\t\t\t\t_addListener(ScrollTrigger, \"scrollEnd\", _softRefresh);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t_refreshing = 1;\n\t\t\tscrubTween && scrubTween.pause();\n\t\t\tinvalidateOnRefresh && animation && animation.progress(0).invalidate();\n\t\t\tself.isReverted || self.revert();\n\t\t\tlet size = getScrollerSize(),\n\t\t\t\tscrollerBounds = getScrollerOffsets(),\n\t\t\t\tmax = containerAnimation ? containerAnimation.duration() : _maxScroll(scroller, direction),\n\t\t\t\toffset = 0,\n\t\t\t\totherPinOffset = 0,\n\t\t\t\tparsedEnd = vars.end,\n\t\t\t\tparsedEndTrigger = vars.endTrigger || trigger,\n\t\t\t\tparsedStart = vars.start || (vars.start === 0 || !trigger ? 0 : (pin ? \"0 0\" : \"0 100%\")),\n\t\t\t\tpinnedContainer = vars.pinnedContainer && _getTarget(vars.pinnedContainer),\n\t\t\t\ttriggerIndex = (trigger && Math.max(0, _triggers.indexOf(self))) || 0,\n\t\t\t\ti = triggerIndex,\n\t\t\t\tcs, bounds, scroll, isVertical, override, curTrigger, curPin, oppositeScroll, initted, revertedPins;\n\t\t\twhile (i--) { // user might try to pin the same element more than once, so we must find any prior triggers with the same pin, revert them, and determine how long they're pinning so that we can offset things appropriately. Make sure we revert from last to first so that things \"rewind\" properly.\n\t\t\t\tcurTrigger = _triggers[i];\n\t\t\t\tcurTrigger.end || curTrigger.refresh(0, 1) || (_refreshing = 1); // if it's a timeline-based trigger that hasn't been fully initialized yet because it's waiting for 1 tick, just force the refresh() here, otherwise if it contains a pin that's supposed to affect other ScrollTriggers further down the page, they won't be adjusted properly.\n\t\t\t\tcurPin = curTrigger.pin;\n\t\t\t\tif (curPin && (curPin === trigger || curPin === pin) && !curTrigger.isReverted) {\n\t\t\t\t\trevertedPins || (revertedPins = []);\n\t\t\t\t\trevertedPins.unshift(curTrigger); // we'll revert from first to last to make sure things reach their end state properly\n\t\t\t\t\tcurTrigger.revert();\n\t\t\t\t}\n\t\t\t}\n\t\t\t_isFunction(parsedStart) && (parsedStart = parsedStart(self));\n\t\t\tstart = _parsePosition(parsedStart, trigger, size, direction, scrollFunc(), markerStart, markerStartTrigger, self, scrollerBounds, borderWidth, useFixedPosition, max, containerAnimation) || (pin ? -0.001 : 0);\n\t\t\t_isFunction(parsedEnd) && (parsedEnd = parsedEnd(self));\n\t\t\tif (_isString(parsedEnd) && !parsedEnd.indexOf(\"+=\")) {\n\t\t\t\tif (~parsedEnd.indexOf(\" \")) {\n\t\t\t\t\tparsedEnd = (_isString(parsedStart) ? parsedStart.split(\" \")[0] : \"\") + parsedEnd;\n\t\t\t\t} else {\n\t\t\t\t\toffset = _offsetToPx(parsedEnd.substr(2), size);\n\t\t\t\t\tparsedEnd = _isString(parsedStart) ? parsedStart : start + offset; // _parsePosition won't factor in the offset if the start is a number, so do it here.\n\t\t\t\t\tparsedEndTrigger = trigger;\n\t\t\t\t}\n\t\t\t}\n\t\t\tend = Math.max(start, _parsePosition(parsedEnd || (parsedEndTrigger ? \"100% 0\" : max), parsedEndTrigger, size, direction, scrollFunc() + offset, markerEnd, markerEndTrigger, self, scrollerBounds, borderWidth, useFixedPosition, max, containerAnimation)) || -0.001;\n\t\t\tchange = (end - start) || ((start -= 0.01) && 0.001);\n\n\t\t\toffset = 0;\n\t\t\ti = triggerIndex;\n\t\t\twhile (i--) {\n\t\t\t\tcurTrigger = _triggers[i];\n\t\t\t\tcurPin = curTrigger.pin;\n\t\t\t\tif (curPin && curTrigger.start - curTrigger._pinPush < start && !containerAnimation) {\n\t\t\t\t\tcs = curTrigger.end - curTrigger.start;\n\t\t\t\t\t(curPin === trigger || curPin === pinnedContainer) && !_isNumber(parsedStart) && (offset += cs); // numeric start values shouldn't be offset at all - treat them as absolute\n\t\t\t\t\tcurPin === pin && (otherPinOffset += cs);\n\t\t\t\t}\n\t\t\t}\n\t\t\tstart += offset;\n\t\t\tend += offset;\n\t\t\tself._pinPush = otherPinOffset;\n\t\t\tif (markerStart && offset) { // offset the markers if necessary\n\t\t\t\tcs = {};\n\t\t\t\tcs[direction.a] = \"+=\" + offset;\n\t\t\t\tpinnedContainer && (cs[direction.p] = \"-=\" + scrollFunc());\n\t\t\t\tgsap.set([markerStart, markerEnd], cs);\n\t\t\t}\n\n\t\t\tif (pin) {\n\t\t\t\tcs = _getComputedStyle(pin);\n\t\t\t\tisVertical = direction === _vertical;\n\t\t\t\tscroll = scrollFunc(); // recalculate because the triggers can affect the scroll\n\t\t\t\tpinStart = parseFloat(pinGetter(direction.a)) + otherPinOffset;\n\t\t\t\t!max && end > 1 && ((isViewport ? _body : scroller).style[\"overflow-\" + direction.a] = \"scroll\"); // makes sure the scroller has a scrollbar, otherwise if something has width: 100%, for example, it would be too big (exclude the scrollbar). See https://greensock.com/forums/topic/25182-scrolltrigger-width-of-page-increase-where-markers-are-set-to-false/\n\t\t\t\t_swapPinIn(pin, spacer, cs);\n\t\t\t\tpinState = _getState(pin);\n\t\t\t\t// transforms will interfere with the top/left/right/bottom placement, so remove them temporarily. getBoundingClientRect() factors in transforms.\n\t\t\t\tbounds = _getBounds(pin, true);\n\t\t\t\toppositeScroll = useFixedPosition && _getScrollFunc(scroller, isVertical ? _horizontal : _vertical)();\n\t\t\t\tif (pinSpacing) {\n\t\t\t\t\tspacerState = [pinSpacing + direction.os2, change + otherPinOffset + _px];\n\t\t\t\t\tspacerState.t = spacer;\n\t\t\t\t\ti = (pinSpacing === _padding) ? _getSize(pin, direction) + change + otherPinOffset : 0;\n\t\t\t\t\ti && spacerState.push(direction.d, i + _px); // for box-sizing: border-box (must include padding).\n\t\t\t\t\t_setState(spacerState);\n\t\t\t\t\tuseFixedPosition && scrollFunc(prevScroll);\n\t\t\t\t}\n\t\t\t\tif (useFixedPosition) {\n\t\t\t\t\toverride = {\n\t\t\t\t\t\ttop: (bounds.top + (isVertical ? scroll - start : oppositeScroll)) + _px,\n\t\t\t\t\t\tleft: (bounds.left + (isVertical ? oppositeScroll : scroll - start)) + _px,\n\t\t\t\t\t\tboxSizing: \"border-box\",\n\t\t\t\t\t\tposition: \"fixed\"\n\t\t\t\t\t};\n\t\t\t\t\toverride[_width] = override[\"max\" + _Width] = Math.ceil(bounds.width) + _px;\n\t\t\t\t\toverride[_height] = override[\"max\" + _Height] = Math.ceil(bounds.height) + _px;\n\t\t\t\t\toverride[_margin] = override[_margin + _Top] = override[_margin + _Right] = override[_margin + _Bottom] = override[_margin + _Left] = \"0\";\n\t\t\t\t\toverride[_padding] = cs[_padding];\n\t\t\t\t\toverride[_padding + _Top] = cs[_padding + _Top];\n\t\t\t\t\toverride[_padding + _Right] = cs[_padding + _Right];\n\t\t\t\t\toverride[_padding + _Bottom] = cs[_padding + _Bottom];\n\t\t\t\t\toverride[_padding + _Left] = cs[_padding + _Left];\n\t\t\t\t\tpinActiveState = _copyState(pinOriginalState, override, pinReparent);\n\t\t\t\t}\n\t\t\t\tif (animation) { // the animation might be affecting the transform, so we must jump to the end, check the value, and compensate accordingly. Otherwise, when it becomes unpinned, the pinSetter() will get set to a value that doesn't include whatever the animation did.\n\t\t\t\t\tinitted = animation._initted; // if not, we must invalidate() after this step, otherwise it could lock in starting values prematurely.\n\t\t\t\t\t_suppressOverwrites(1);\n\t\t\t\t\tanimation.render(animation.duration(), true, true);\n\t\t\t\t\tpinChange = pinGetter(direction.a) - pinStart + change + otherPinOffset;\n\t\t\t\t\tchange !== pinChange && pinActiveState.splice(pinActiveState.length - 2, 2); // transform is the last property/value set in the state Array. Since the animation is controlling that, we should omit it.\n\t\t\t\t\tanimation.render(0, true, true);\n\t\t\t\t\tinitted || animation.invalidate();\n\t\t\t\t\t_suppressOverwrites(0);\n\t\t\t\t} else {\n\t\t\t\t\tpinChange = change\n\t\t\t\t}\n\t\t\t} else if (trigger && scrollFunc() && !containerAnimation) { // it may be INSIDE a pinned element, so walk up the tree and look for any elements with _pinOffset to compensate because anything with pinSpacing that's already scrolled would throw off the measurements in getBoundingClientRect()\n\t\t\t\tbounds = trigger.parentNode;\n\t\t\t\twhile (bounds && bounds !== _body) {\n\t\t\t\t\tif (bounds._pinOffset) {\n\t\t\t\t\t\tstart -= bounds._pinOffset;\n\t\t\t\t\t\tend -= bounds._pinOffset;\n\t\t\t\t\t}\n\t\t\t\t\tbounds = bounds.parentNode;\n\t\t\t\t}\n\t\t\t}\n\t\t\trevertedPins && revertedPins.forEach(t => t.revert(false));\n\t\t\tself.start = start;\n\t\t\tself.end = end;\n\t\t\tscroll1 = scroll2 = scrollFunc(); // reset velocity\n\t\t\tif (!containerAnimation) {\n\t\t\t\tscroll1 < prevScroll && scrollFunc(prevScroll);\n\t\t\t\tself.scroll.rec = 0;\n\t\t\t}\n\t\t\tself.revert(false);\n\t\t\t_refreshing = 0;\n\t\t\tanimation && isToggle && animation._initted && animation.progress() !== prevAnimProgress && animation.progress(prevAnimProgress, true).render(animation.time(), true, true); // must force a re-render because if saveStyles() was used on the target(s), the styles could have been wiped out during the refresh().\n\t\t\tif (prevProgress !== self.progress) { // ensures that the direction is set properly (when refreshing, progress is set back to 0 initially, then back again to wherever it needs to be) and that callbacks are triggered.\n\t\t\t\tanimation && !isToggle && animation.totalProgress(prevProgress, true); // to avoid issues where animation callbacks like onStart aren't triggered.\n\t\t\t\tself.progress = prevProgress;\n\t\t\t\tself.update(0, 0, 1);\n\t\t\t}\n\t\t\tpin && pinSpacing && (spacer._pinOffset = Math.round(self.progress * pinChange));\n\t\t\tonRefresh && onRefresh(self);\n\t\t};\n\n\t\tself.getVelocity = () => ((scrollFunc() - scroll2) / (_getTime() - _time2) * 1000) || 0;\n\n\t\tself.endAnimation = () => {\n\t\t\t_endAnimation(self.callbackAnimation);\n\t\t\tif (animation) {\n\t\t\t\tscrubTween ? scrubTween.progress(1) : (!animation.paused() ? _endAnimation(animation, animation.reversed()) : isToggle || _endAnimation(animation, self.direction < 0, 1));\n\t\t\t}\n\t\t};\n\n\t\tself.getTrailing = name => {\n\t\t\tlet i = _triggers.indexOf(self),\n\t\t\t\ta = self.direction > 0 ? _triggers.slice(0, i).reverse() : _triggers.slice(i+1);\n\t\t\treturn _isString(name) ? a.filter(t => t.vars.preventOverlaps === name) : a;\n\t\t};\n\n\n\t\tself.update = (reset, recordVelocity, forceFake) => {\n\t\t\tif (containerAnimation && !forceFake && !reset) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlet scroll = self.scroll(),\n\t\t\t\tp = reset ? 0 : (scroll - start) / change,\n\t\t\t\tclipped = p < 0 ? 0 : p > 1 ? 1 : p || 0,\n\t\t\t\tprevProgress = self.progress,\n\t\t\t\tisActive, wasActive, toggleState, action, stateChanged, toggled, isAtMax, isTakingAction;\n\t\t\tif (recordVelocity) {\n\t\t\t\tscroll2 = scroll1;\n\t\t\t\tscroll1 = containerAnimation ? scrollFunc() : scroll;\n\t\t\t\tif (snap) {\n\t\t\t\t\tsnap2 = snap1;\n\t\t\t\t\tsnap1 = animation && !isToggle ? animation.totalProgress() : clipped;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// anticipate the pinning a few ticks ahead of time based on velocity to avoid a visual glitch due to the fact that most browsers do scrolling on a separate thread (not synced with requestAnimationFrame).\n\t\t\t(anticipatePin && !clipped && pin && !_refreshing && !_startup && _lastScrollTime && start < scroll + ((scroll - scroll2) / (_getTime() - _time2)) * anticipatePin) && (clipped = 0.0001);\n\t\t\tif (clipped !== prevProgress && self.enabled) {\n\t\t\t\tisActive = self.isActive = !!clipped && clipped < 1;\n\t\t\t\twasActive = !!prevProgress && prevProgress < 1;\n\t\t\t\ttoggled = isActive !== wasActive;\n\t\t\t\tstateChanged = toggled || !!clipped !== !!prevProgress; // could go from start all the way to end, thus it didn't toggle but it did change state in a sense (may need to fire a callback)\n\t\t\t\tself.direction = clipped > prevProgress ? 1 : -1;\n\t\t\t\tself.progress = clipped;\n\n\t\t\t\tif (stateChanged && !_refreshing) {\n\t\t\t\t\ttoggleState = clipped && !prevProgress ? 0 : clipped === 1 ? 1 : prevProgress === 1 ? 2 : 3; // 0 = enter, 1 = leave, 2 = enterBack, 3 = leaveBack (we prioritize the FIRST encounter, thus if you scroll really fast past the onEnter and onLeave in one tick, it'd prioritize onEnter.\n\t\t\t\t\tif (isToggle) {\n\t\t\t\t\t\taction = (!toggled && toggleActions[toggleState + 1] !== \"none\" && toggleActions[toggleState + 1]) || toggleActions[toggleState]; // if it didn't toggle, that means it shot right past and since we prioritize the \"enter\" action, we should switch to the \"leave\" in this case (but only if one is defined)\n\t\t\t\t\t\tisTakingAction = animation && (action === \"complete\" || action === \"reset\" || action in animation);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tpreventOverlaps && toggled && (isTakingAction || scrub || !animation) && (_isFunction(preventOverlaps) ? preventOverlaps(self) : self.getTrailing(preventOverlaps).forEach(t => t.endAnimation()));\n\n\t\t\t\tif (!isToggle) {\n\t\t\t\t\tif (scrubTween && !_refreshing && !_startup) {\n\t\t\t\t\t\tscrubTween.vars.totalProgress = clipped;\n\t\t\t\t\t\tscrubTween.invalidate().restart();\n\t\t\t\t\t} else if (animation) {\n\t\t\t\t\t\tanimation.totalProgress(clipped, !!_refreshing);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pin) {\n\t\t\t\t\treset && pinSpacing && (spacer.style[pinSpacing + direction.os2] = spacingStart);\n\t\t\t\t\tif (!useFixedPosition) {\n\t\t\t\t\t\tpinSetter(pinStart + pinChange * clipped);\n\t\t\t\t\t} else if (stateChanged) {\n\t\t\t\t\t\tisAtMax = !reset && clipped > prevProgress && end + 1 > scroll && scroll + 1 >= _maxScroll(scroller, direction); // if it's at the VERY end of the page, don't switch away from position: fixed because it's pointless and it could cause a brief flash when the user scrolls back up (when it gets pinned again)\n\t\t\t\t\t\tif (pinReparent) {\n\t\t\t\t\t\t\tif (!reset && (isActive || isAtMax)) {\n\t\t\t\t\t\t\t\tlet bounds = _getBounds(pin, true),\n\t\t\t\t\t\t\t\t\toffset = scroll - start;\n\t\t\t\t\t\t\t\t_reparent(pin, _body, (bounds.top + (direction === _vertical ? offset : 0)) + _px, (bounds.left + (direction === _vertical ? 0 : offset)) + _px);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t_reparent(pin, spacer);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t_setState(isActive || isAtMax ? pinActiveState : pinState);\n\t\t\t\t\t\t(pinChange !== change && clipped < 1 && isActive) || pinSetter(pinStart + (clipped === 1 && !isAtMax ? pinChange : 0));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsnap && !tweenTo.tween && !_refreshing && !_startup && snapDelayedCall.restart(true);\n\t\t\t\ttoggleClass && (toggled || (once && clipped && (clipped < 1 || !_limitCallbacks))) && _toArray(toggleClass.targets).forEach(el => el.classList[isActive || once ? \"add\" : \"remove\"](toggleClass.className)); // classes could affect positioning, so do it even if reset or refreshing is true.\n\t\t\t\tonUpdate && !isToggle && !reset && onUpdate(self);\n\t\t\t\tif (stateChanged && !_refreshing) {\n\t\t\t\t\tif (isToggle) {\n\t\t\t\t\t\tif (isTakingAction) {\n\t\t\t\t\t\t\tif (action === \"complete\") {\n\t\t\t\t\t\t\t\tanimation.pause().totalProgress(1);\n\t\t\t\t\t\t\t} else if (action === \"reset\") {\n\t\t\t\t\t\t\t\tanimation.restart(true).pause();\n\t\t\t\t\t\t\t} else if (action === \"restart\") {\n\t\t\t\t\t\t\t\tanimation.restart(true);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tanimation[action]();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tonUpdate && onUpdate(self);\n\t\t\t\t\t}\n\t\t\t\t\tif (toggled || !_limitCallbacks) { // on startup, the page could be scrolled and we don't want to fire callbacks that didn't toggle. For example onEnter shouldn't fire if the ScrollTrigger isn't actually entered.\n\t\t\t\t\t\tonToggle && toggled && _callback(self, onToggle);\n\t\t\t\t\t\tcallbacks[toggleState] && _callback(self, callbacks[toggleState]);\n\t\t\t\t\t\tonce && (clipped === 1 ? self.kill(false, 1) : (callbacks[toggleState] = 0)); // a callback shouldn't be called again if once is true.\n\t\t\t\t\t\tif (!toggled) { // it's possible to go completely past, like from before the start to after the end (or vice-versa) in which case BOTH callbacks should be fired in that order\n\t\t\t\t\t\t\ttoggleState = clipped === 1 ? 1 : 3;\n\t\t\t\t\t\t\tcallbacks[toggleState] && _callback(self, callbacks[toggleState]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (fastScrollEnd && !isActive && Math.abs(self.getVelocity()) > (_isNumber(fastScrollEnd) ? fastScrollEnd : 2500)) {\n\t\t\t\t\t\t_endAnimation(self.callbackAnimation);\n\t\t\t\t\t\tscrubTween ? scrubTween.progress(1) : _endAnimation(animation, !clipped, 1);\n\t\t\t\t\t}\n\t\t\t\t} else if (isToggle && onUpdate && !_refreshing) {\n\t\t\t\t\tonUpdate(self);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// update absolutely-positioned markers (only if the scroller isn't the viewport)\n\t\t\tif (markerEndSetter) {\n\t\t\t\tlet n = containerAnimation ? scroll / containerAnimation.duration() * (containerAnimation._caScrollDist || 0) : scroll;\n\t\t\t\tmarkerStartSetter(n + (markerStartTrigger._isFlipped ? 1 : 0));\n\t\t\t\tmarkerEndSetter(n);\n\t\t\t}\n\t\t\tcaMarkerSetter && caMarkerSetter(-scroll / containerAnimation.duration() * (containerAnimation._caScrollDist || 0));\n\t\t};\n\n\t\tself.enable = (reset, refresh) => {\n\t\t\tif (!self.enabled) {\n\t\t\t\tself.enabled = true;\n\t\t\t\t_addListener(scroller, \"resize\", _onResize);\n\t\t\t\t_addListener(scroller, \"scroll\", _onScroll);\n\t\t\t\tonRefreshInit && _addListener(ScrollTrigger, \"refreshInit\", onRefreshInit);\n\t\t\t\tif (reset !== false) {\n\t\t\t\t\tself.progress = prevProgress = 0;\n\t\t\t\t\tscroll1 = scroll2 = lastSnap = scrollFunc();\n\t\t\t\t}\n\t\t\t\trefresh !== false && self.refresh();\n\t\t\t}\n\t\t};\n\n\t\tself.getTween = snap => snap && tweenTo ? tweenTo.tween : scrubTween;\n\n\t\tself.disable = (reset, allowAnimation) => {\n\t\t\tif (self.enabled) {\n\t\t\t\treset !== false && self.revert();\n\t\t\t\tself.enabled = self.isActive = false;\n\t\t\t\tallowAnimation || (scrubTween && scrubTween.pause());\n\t\t\t\tprevScroll = 0;\n\t\t\t\tpinCache && (pinCache.uncache = 1);\n\t\t\t\tonRefreshInit && _removeListener(ScrollTrigger, \"refreshInit\", onRefreshInit);\n\t\t\t\tif (snapDelayedCall) {\n\t\t\t\t\tsnapDelayedCall.pause();\n\t\t\t\t\ttweenTo.tween && tweenTo.tween.kill() && (tweenTo.tween = 0);\n\t\t\t\t}\n\t\t\t\tif (!isViewport) {\n\t\t\t\t\tlet i = _triggers.length;\n\t\t\t\t\twhile (i--) {\n\t\t\t\t\t\tif (_triggers[i].scroller === scroller && _triggers[i] !== self) {\n\t\t\t\t\t\t\treturn; //don't remove the listeners if there are still other triggers referencing it.\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t_removeListener(scroller, \"resize\", _onResize);\n\t\t\t\t\t_removeListener(scroller, \"scroll\", _onScroll);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tself.kill = (revert, allowAnimation) => {\n\t\t\tself.disable(revert, allowAnimation);\n\t\t\tscrubTween && scrubTween.kill();\n\t\t\tid && (delete _ids[id]);\n\t\t\tlet i = _triggers.indexOf(self);\n\t\t\t_triggers.splice(i, 1);\n\t\t\ti === _i && _direction > 0 && _i--; // if we're in the middle of a refresh() or update(), splicing would cause skips in the index, so adjust...\n\n\t\t\t// if no other ScrollTrigger instances of the same scroller are found, wipe out any recorded scroll position. Otherwise, in a single page application, for example, it could maintain scroll position when it really shouldn't.\n\t\t\ti = 0;\n\t\t\t_triggers.forEach(t => t.scroller === self.scroller && (i = 1));\n\t\t\ti || (self.scroll.rec = 0);\n\n\t\t\tif (animation) {\n\t\t\t\tanimation.scrollTrigger = null;\n\t\t\t\trevert && animation.render(-1);\n\t\t\t\tallowAnimation || animation.kill();\n\t\t\t}\n\t\t\tmarkerStart && [markerStart, markerEnd, markerStartTrigger, markerEndTrigger].forEach(m => m.parentNode && m.parentNode.removeChild(m));\n\t\t\tif (pin) {\n\t\t\t\tpinCache && (pinCache.uncache = 1);\n\t\t\t\ti = 0;\n\t\t\t\t_triggers.forEach(t => t.pin === pin && i++);\n\t\t\t\ti || (pinCache.spacer = 0); // if there aren't any more ScrollTriggers with the same pin, remove the spacer, otherwise it could be contaminated with old/stale values if the user re-creates a ScrollTrigger for the same element.\n\t\t\t}\n\t\t};\n\n\t\tself.enable(false, false);\n\t\t!animation || !animation.add || change ? self.refresh() : gsap.delayedCall(0.01, () => start || end || self.refresh()) && (change = 0.01) && (start = end = 0); // if the animation is a timeline, it may not have been populated yet, so it wouldn't render at the proper place on the first refresh(), thus we should schedule one for the next tick. If \"change\" is defined, we know it must be re-enabling, thus we can refresh() right away.\n\t}\n\n\n\tstatic register(core) {\n\t\tif (!_coreInitted) {\n\t\t\tgsap = core || _getGSAP();\n\t\t\tif (_windowExists() && window.document) {\n\t\t\t\t_win = window;\n\t\t\t\t_doc = document;\n\t\t\t\t_docEl = _doc.documentElement;\n\t\t\t\t_body = _doc.body;\n\t\t\t}\n\t\t\tif (gsap) {\n\t\t\t\t_toArray = gsap.utils.toArray;\n\t\t\t\t_clamp = gsap.utils.clamp;\n\t\t\t\t_suppressOverwrites = gsap.core.suppressOverwrites || _passThrough;\n\t\t\t\tgsap.core.globals(\"ScrollTrigger\", ScrollTrigger); // must register the global manually because in Internet Explorer, functions (classes) don't have a \"name\" property.\n\t\t\t\tif (_body) {\n\t\t\t\t\t_raf = _win.requestAnimationFrame || (f => setTimeout(f, 16));\n\t\t\t\t\t_addListener(_win, \"wheel\", _onScroll);\n\t\t\t\t\t_root = [_win, _doc, _docEl, _body];\n\t\t\t\t\t_addListener(_doc, \"scroll\", _onScroll); // some browsers (like Chrome), the window stops dispatching scroll events on the window if you scroll really fast, but it's consistent on the document!\n\t\t\t\t\tlet bodyStyle = _body.style,\n\t\t\t\t\t\tborder = bodyStyle.borderTopStyle,\n\t\t\t\t\t\tbounds;\n\t\t\t\t\tbodyStyle.borderTopStyle = \"solid\"; // works around an issue where a margin of a child element could throw off the bounds of the _body, making it seem like there's a margin when there actually isn't. The border ensures that the bounds are accurate.\n\t\t\t\t\tbounds = _getBounds(_body);\n\t\t\t\t\t_vertical.m = Math.round(bounds.top + _vertical.sc()) || 0; // accommodate the offset of the <body> caused by margins and/or padding\n\t\t\t\t\t_horizontal.m = Math.round(bounds.left + _horizontal.sc()) || 0;\n\t\t\t\t\tborder ? (bodyStyle.borderTopStyle = border) : bodyStyle.removeProperty(\"border-top-style\");\n\t\t\t\t\t_syncInterval = setInterval(_sync, 200);\n\t\t\t\t\tgsap.delayedCall(0.5, () => _startup = 0);\n\t\t\t\t\t_addListener(_doc, \"touchcancel\", _passThrough); // some older Android devices intermittently stop dispatching \"touchmove\" events if we don't listen for \"touchcancel\" on the document.\n\t\t\t\t\t_addListener(_body, \"touchstart\", _passThrough); //works around Safari bug: https://greensock.com/forums/topic/21450-draggable-in-iframe-on-mobile-is-buggy/\n\t\t\t\t\t_multiListener(_addListener, _doc, \"pointerdown,touchstart,mousedown\", () => _pointerIsDown = 1);\n\t\t\t\t\t_multiListener(_addListener, _doc, \"pointerup,touchend,mouseup\", () => _pointerIsDown = 0);\n\t\t\t\t\t_transformProp = gsap.utils.checkPrefix(\"transform\");\n\t\t\t\t\t_stateProps.push(_transformProp);\n\t\t\t\t\t_coreInitted = _getTime();\n\t\t\t\t\t_resizeDelay = gsap.delayedCall(0.2, _refreshAll).pause();\n\t\t\t\t\t_autoRefresh = [_doc, \"visibilitychange\", () => {\n\t\t\t\t\t\tlet w = _win.innerWidth,\n\t\t\t\t\t\t\th = _win.innerHeight;\n\t\t\t\t\t\tif (_doc.hidden) {\n\t\t\t\t\t\t\t_prevWidth = w;\n\t\t\t\t\t\t\t_prevHeight = h;\n\t\t\t\t\t\t} else if (_prevWidth !== w || _prevHeight !== h) {\n\t\t\t\t\t\t\t_onResize();\n\t\t\t\t\t\t}\n\t\t\t\t\t}, _doc, \"DOMContentLoaded\", _refreshAll, _win, \"load\", () => _lastScrollTime || _refreshAll(), _win, \"resize\", _onResize];\n\t\t\t\t\t_iterateAutoRefresh(_addListener);\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn _coreInitted;\n\t}\n\n\tstatic defaults(config) {\n\t\tfor (let p in config) {\n\t\t\t_defaults[p] = config[p];\n\t\t}\n\t}\n\n\tstatic kill() {\n\t\t_enabled = 0;\n\t\t_triggers.slice(0).forEach(trigger => trigger.kill(1));\n\t}\n\n\tstatic config(vars) {\n\t\t(\"limitCallbacks\" in vars) && (_limitCallbacks = !!vars.limitCallbacks);\n\t\tlet ms = vars.syncInterval;\n\t\tms && clearInterval(_syncInterval) || ((_syncInterval = ms) && setInterval(_sync, ms));\n\t\tif (\"autoRefreshEvents\" in vars) {\n\t\t\t_iterateAutoRefresh(_removeListener) || _iterateAutoRefresh(_addListener, vars.autoRefreshEvents || \"none\");\n\t\t\t_ignoreResize = (vars.autoRefreshEvents + \"\").indexOf(\"resize\") === -1;\n\t\t}\n\t}\n\n\tstatic scrollerProxy(target, vars) {\n\t\tlet t = _getTarget(target),\n\t\t\ti = _scrollers.indexOf(t),\n\t\t\tisViewport = _isViewport(t);\n\t\tif (~i) {\n\t\t\t_scrollers.splice(i, isViewport ? 6 : 2);\n\t\t}\n\t\tisViewport ? _proxies.unshift(_win, vars, _body, vars, _docEl, vars) : _proxies.unshift(t, vars);\n\t}\n\n\tstatic matchMedia(vars) { // _media is populated in the following order: mediaQueryString, onMatch, onUnmatch, isMatched. So if there are two media queries, the Array would have a length of 8\n\t\tlet mq, p, i, func, result;\n\t\tfor (p in vars) {\n\t\t\ti = _media.indexOf(p);\n\t\t\tfunc = vars[p];\n\t\t\t_creatingMedia = p;\n\t\t\tif (p === \"all\") {\n\t\t\t\tfunc();\n\t\t\t} else {\n\t\t\t\tmq = _win.matchMedia(p);\n\t\t\t\tif (mq) {\n\t\t\t\t\tmq.matches && (result = func());\n\t\t\t\t\tif (~i) {\n\t\t\t\t\t\t_media[i + 1] = _combineFunc(_media[i + 1], func);\n\t\t\t\t\t\t_media[i + 2] = _combineFunc(_media[i + 2], result);\n\t\t\t\t\t} else {\n\t\t\t\t\t\ti = _media.length;\n\t\t\t\t\t\t_media.push(p, func, result);\n\t\t\t\t\t\tmq.addListener ? mq.addListener(_onMediaChange) : mq.addEventListener(\"change\", _onMediaChange);\n\t\t\t\t\t}\n\t\t\t\t\t_media[i + 3] = mq.matches;\n\t\t\t\t}\n\t\t\t}\n\t\t\t_creatingMedia = 0;\n\t\t}\n\t\treturn _media;\n\t}\n\n\tstatic clearMatchMedia(query) {\n\t\tquery || (_media.length = 0);\n\t\tquery = _media.indexOf(query);\n\t\tquery >= 0 && _media.splice(query, 4);\n\t}\n\n\tstatic isInViewport(element, ratio, horizontal) {\n\t\tlet bounds = (_isString(element) ? _getTarget(element) : element).getBoundingClientRect(),\n\t\t\toffset = bounds[horizontal ? _width : _height] * ratio || 0;\n\t\treturn horizontal ? bounds.right - offset > 0 && bounds.left + offset < _win.innerWidth : bounds.bottom - offset > 0 && bounds.top + offset < _win.innerHeight;\n\t}\n\n\tstatic positionInViewport(element, referencePoint, horizontal) {\n\t\t_isString(element) && (element = _getTarget(element));\n\t\tlet bounds = element.getBoundingClientRect(),\n\t\t\tsize = bounds[horizontal ? _width : _height],\n\t\t\toffset = referencePoint == null ? size / 2 : ((referencePoint in _keywords) ? _keywords[referencePoint] * size : ~referencePoint.indexOf(\"%\") ? parseFloat(referencePoint) * size / 100 : parseFloat(referencePoint) || 0);\n\t\treturn horizontal ? (bounds.left + offset) / _win.innerWidth : (bounds.top + offset) / _win.innerHeight;\n\t}\n\n}\n\nScrollTrigger.version = \"3.8.0\";\nScrollTrigger.saveStyles = targets => targets ? _toArray(targets).forEach(target => { // saved styles are recorded in a consecutive alternating Array, like [element, cssText, transform attribute, cache, matchMedia, ...]\n\tif (target && target.style) {\n\t\tlet i = _savedStyles.indexOf(target);\n\t\ti >= 0 && _savedStyles.splice(i, 5);\n\t\t_savedStyles.push(target, target.style.cssText, target.getBBox && target.getAttribute(\"transform\"), gsap.core.getCache(target), _creatingMedia);\n\t}\n}) : _savedStyles;\nScrollTrigger.revert = (soft, media) => _revertAll(!soft, media);\nScrollTrigger.create = (vars, animation) => new ScrollTrigger(vars, animation);\nScrollTrigger.refresh = safe => safe ? _onResize() : (_coreInitted || ScrollTrigger.register()) && _refreshAll(true);\nScrollTrigger.update = _updateAll;\nScrollTrigger.clearScrollMemory = _clearScrollMemory;\nScrollTrigger.maxScroll = (element, horizontal) => _maxScroll(element, horizontal ? _horizontal : _vertical);\nScrollTrigger.getScrollFunc = (element, horizontal) => _getScrollFunc(_getTarget(element), horizontal ? _horizontal : _vertical);\nScrollTrigger.getById = id => _ids[id];\nScrollTrigger.getAll = () => _triggers.slice(0);\nScrollTrigger.isScrolling = () => !!_lastScrollTime;\nScrollTrigger.snapDirectional = _snapDirectional;\nScrollTrigger.addEventListener = (type, callback) => {\n\tlet a = _listeners[type] || (_listeners[type] = []);\n\t~a.indexOf(callback) || a.push(callback);\n};\nScrollTrigger.removeEventListener = (type, callback) => {\n\tlet a = _listeners[type],\n\t\ti = a && a.indexOf(callback);\n\ti >= 0 && a.splice(i, 1);\n};\nScrollTrigger.batch = (targets, vars) => {\n\tlet result = [],\n\t\tvarsCopy = {},\n\t\tinterval = vars.interval || 0.016,\n\t\tbatchMax = vars.batchMax || 1e9,\n\t\tproxyCallback = (type, callback) => {\n\t\t\tlet elements = [],\n\t\t\t\ttriggers = [],\n\t\t\t\tdelay = gsap.delayedCall(interval, () => {callback(elements, triggers); elements = []; triggers = [];}).pause();\n\t\t\treturn self => {\n\t\t\t\telements.length || delay.restart(true);\n\t\t\t\telements.push(self.trigger);\n\t\t\t\ttriggers.push(self);\n\t\t\t\tbatchMax <= elements.length && delay.progress(1);\n\t\t\t};\n\t\t},\n\t\tp;\n\tfor (p in vars) {\n\t\tvarsCopy[p] = (p.substr(0, 2) === \"on\" && _isFunction(vars[p]) && p !== \"onRefreshInit\") ? proxyCallback(p, vars[p]) : vars[p];\n\t}\n\tif (_isFunction(batchMax)) {\n\t\tbatchMax = batchMax();\n\t\t_addListener(ScrollTrigger, \"refresh\", () => batchMax = vars.batchMax());\n\t}\n\t_toArray(targets).forEach(target => {\n\t\tlet config = {};\n\t\tfor (p in varsCopy) {\n\t\t\tconfig[p] = varsCopy[p];\n\t\t}\n\t\tconfig.trigger = target;\n\t\tresult.push(ScrollTrigger.create(config));\n\t});\n\treturn result;\n}\nScrollTrigger.sort = func => _triggers.sort(func || ((a, b) => (a.vars.refreshPriority || 0) * -1e6 + a.start - (b.start + (b.vars.refreshPriority || 0) * -1e6)));\n\n_getGSAP() && gsap.registerPlugin(ScrollTrigger);\n\nexport { ScrollTrigger as default };"],"names":["_passThrough","v","_getTarget","t","_toArray","_isString","console","warn","_round","value","Math","round","_windowExists","window","_getGSAP","gsap","registerPlugin","_isViewport","e","_root","indexOf","_getProxyProp","element","property","_proxies","_getScrollFunc","s","sc","i","_scrollers","offset","_vertical","push","arguments","length","_getBoundsFunc","_winOffsets","width","_win","innerWidth","height","innerHeight","_getBounds","_maxScroll","d2","d","a","_body","_docEl","_iterateAutoRefresh","func","events","_autoRefresh","_isFunction","_isNumber","_isObject","_callIfFunc","_combineFunc","f1","f2","result1","result2","_endAnimation","animation","reversed","pause","progress","_callback","self","result","totalTime","callbackAnimation","_getComputedStyle","getComputedStyle","_setDefaults","obj","defaults","p","_getSize","_getLabelRatioArray","timeline","labels","duration","_snapDirectional","snapIncrementOrArray","snap","utils","Array","isArray","slice","sort","b","direction","snapped","abs","_multiListener","types","callback","split","forEach","type","_addListener","addEventListener","passive","_removeListener","removeEventListener","_offsetToPx","size","eqIndex","relative","charAt","parseFloat","substr","_keywords","_createMarker","name","container","matchWidthEl","containerAnimation","startColor","endColor","fontSize","indent","fontWeight","_doc","createElement","useFixedPosition","isScroller","parent","isStart","color","css","_right","_bottom","offsetWidth","_isStart","setAttribute","style","cssText","innerText","children","insertBefore","appendChild","_offset","op","_positionMarker","_sync","_getTime","_lastScrollTime","_updateAll","_onScroll","time","_dispatch","_request","_raf","_onResize","_refreshing","_ignoreResize","fullscreenElement","_resizeDelay","restart","_onMediaChange","index","tick","ticker","frame","matches","_lastMediaTick","_startup","_revertAll","_media","matchMedia","_revertRecorded","_creatingMedia","_coreInitted","_refreshAll","_softRefresh","ScrollTrigger","_clearScrollMemory","rec","_swapPinIn","pin","spacer","cs","spacerState","parentNode","_propNamesToCopy","spacerStyle","pinStyle","position","display","overflow","boxSizing","_width","_horizontal","_px","_height","_padding","_margin","_left","_setState","_getState","l","_stateProps","state","_parsePosition","trigger","scrollerSize","scroll","marker","markerScroller","scrollerBounds","borderWidth","scrollerMax","p1","p2","seek","bounds","localOffset","globalOffset","offsets","left","top","removeProperty","max","m","_caScrollDist","_reparent","_stOrig","_prefixExp","test","core","getCache","uncache","_getTweenCreator","scroller","getTween","scrollTo","vars","initialValue","change1","change2","tween","onComplete","modifiers","kill","lastScroll1","prop","getScroll","lastScroll2","ratio","call","to","_clamp","_time2","_syncInterval","_pointerIsDown","_transformProp","_i","_prevWidth","_prevHeight","_sort","_suppressOverwrites","_limitCallbacks","_refreshingAll","Date","now","_time1","_enabled","_abs","_scrollLeft","_scrollTop","_Right","_Left","_Top","_Bottom","_Width","_Height","os","os2","pageXOffset","pageYOffset","withoutTransforms","x","y","xPercent","yPercent","rotation","rotationX","rotationY","scale","skewX","skewY","getBoundingClientRect","_markerDefaults","_defaults","toggleActions","anticipatePin","center","bottom","right","start","flipped","side","oppositeSide","_isFlipped","set","_triggers","_ids","_listeners","_emptyArray","map","f","_savedStyles","media","getBBox","revert","force","skipRevert","refreshInits","refresh","render","_lastScroll","_direction","recordVelocity","update","concat","_capsExp","_gsap","replace","toLowerCase","init","this","tweenTo","pinCache","snapFunc","scroll1","scroll2","end","markerStart","markerEnd","markerStartTrigger","markerEndTrigger","markerVars","change","pinOriginalState","pinActiveState","pinState","pinGetter","pinSetter","pinStart","pinChange","spacingStart","markerStartSetter","markerEndSetter","snap1","snap2","scrubTween","scrubSmooth","snapDurClamp","snapDelayedCall","prevProgress","prevScroll","prevAnimProgress","caMarkerSetter","onUpdate","nodeType","toggleClass","id","onToggle","onRefresh","scrub","pinSpacing","invalidateOnRefresh","onScrubComplete","onSnapComplete","once","pinReparent","pinSpacer","fastScrollEnd","preventOverlaps","horizontal","isToggle","scrollerCache","isViewport","pinType","callbacks","onEnter","onLeave","onEnterBack","onLeaveBack","markers","onRefreshInit","getScrollerSize","_getSizeFunc","getScrollerOffsets","_getOffsetsFunc","lastSnap","scrollFunc","bind","tweenScroll","lazy","_initted","immediateRender","scrollTrigger","ease","snapTo","scrollBehavior","_getClosestLabel","_getLabelAtDirection","st","directional","min","delayedCall","delay","getVelocity","totalProgress","velocity","clamp","naturalEnd","inertia","endValue","endScroll","onStart","onInterrupt","data","isActive","targets","className","force3D","current","nativeElement","spacerIsNative","classList","add","getProperty","quickSetter","_makePositionable","oldOnUpdate","oldParams","onUpdateParams","eventCallback","apply","previous","next","r","enabled","prevRefreshing","isReverted","_swapPinOut","cache","removeChild","soft","invalidate","isVertical","override","curTrigger","curPin","oppositeScroll","initted","revertedPins","otherPinOffset","parsedEnd","parsedEndTrigger","endTrigger","parsedStart","pinnedContainer","triggerIndex","unshift","_pinPush","ceil","_copyState","omitOffsets","splice","_pinOffset","endAnimation","paused","getTrailing","reverse","filter","reset","forceFake","toggleState","action","stateChanged","toggled","isAtMax","isTakingAction","clipped","el","n","enable","disable","allowAnimation","register","document","documentElement","body","toArray","suppressOverwrites","globals","requestAnimationFrame","setTimeout","bodyStyle","border","borderTopStyle","setInterval","checkPrefix","w","h","hidden","config","limitCallbacks","ms","syncInterval","clearInterval","autoRefreshEvents","scrollerProxy","target","mq","addListener","clearMatchMedia","query","isInViewport","positionInViewport","referencePoint","version","saveStyles","getAttribute","create","safe","clearScrollMemory","maxScroll","getScrollFunc","getById","getAll","isScrolling","snapDirectional","batch","proxyCallback","elements","triggers","interval","batchMax","varsCopy","refreshPriority"],"mappings":"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"}